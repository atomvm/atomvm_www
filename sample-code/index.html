<!DOCTYPE html>
<html lang="en" class="html" data-theme="dark"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>
    
      Sample Code
    
  </title>

  <!-- Begin Jekyll SEO tag v2.7.3 -->
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Sample Code" />
<meta name="author" content="atomvm.net" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Welcome to AtomVM, the Erlang virtual machine for IoT devices!" />
<meta property="og:description" content="Welcome to AtomVM, the Erlang virtual machine for IoT devices!" />
<link rel="canonical" href="https://www.atomvm.net/sample-code/" />
<meta property="og:url" content="https://www.atomvm.net/sample-code/" />
<meta property="og:site_name" content="AtomVM" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Sample Code" />
<meta name="twitter:site" content="@abhinav" />
<meta name="twitter:creator" content="@atomvm.net" />
<script type="application/ld+json">
{"headline":"Sample Code","url":"https://www.atomvm.net/sample-code/","author":{"@type":"Person","name":"atomvm.net"},"description":"Welcome to AtomVM, the Erlang virtual machine for IoT devices!","@type":"WebPage","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="https://www.atomvm.net/feed.xml" title="AtomVM" />

  <!-- Favicon -->
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png">
  <link rel="manifest" href="/assets/images/favicon/site.webmanifest">
  <link rel="mask-icon" href="/assets/images/favicon/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="shortcut icon" href="/assets/images/favicon/favicon.ico">
  <meta name="msapplication-TileColor" content="#00aba9">
  <meta name="msapplication-config" content="/assets/images/favicon/browserconfig.xml">
  <meta name="theme-color" content="#ffffff">
  <!-- Favicon -->

  <link rel="stylesheet" href="/assets/css/main.css" />
  
    <script type="text/javascript">
  window.addEventListener('load', themeChange);
  const currentTheme = localStorage.getItem('theme') ? localStorage.getItem('theme') : null;
  if (currentTheme)
    document.documentElement.setAttribute('data-theme', currentTheme);

  function themeChange() {
    let button = document.querySelector('.theme-toggle');

    button.addEventListener('click', function (e) {
      let currentTheme = document.documentElement.getAttribute('data-theme');
      if (currentTheme === 'dark') {
        transition();
        document.documentElement.setAttribute('data-theme', 'light');
        localStorage.setItem('theme', 'light');
      } else {
        transition();
        document.documentElement.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
      }
    });

    let transition = () => {
      document.documentElement.classList.add('transition');
      window.setTimeout(() => {
        document.documentElement.classList.remove('transition');
      }, 1000);
    }
  }
</script>


  <!-- <link rel="shortcut icon" type="image/x-icon" href="/assets/images/favicon/favicon.ico" /> -->

<link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png">
<link rel="manifest" href="/assets/images/favicon/site.webmanifest">
<link rel="shortcut icon" href="/assets/images/favicon/favicon.ico">
</head>
<body>
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">home..</a>
<h1 class="post-title">Sample Code</h1>
<p class="post-date text-bold">
  
  


  
  
  (944 Words, 
  6 Minutes)
  

</p>

<div class="soopr-btn"
   data-twitter="SooprCo"
>
</div>


  <div class="">
    
  </div>


<p>You can get a pretty good idea of how to write programs for AtomVM by looking at examples.  This page has a few to wet your appetite!</p>

<blockquote>
  <p>Note. A passing familiarity with Erlang syntax would be helpful for following along, but most readers familiar with curly-brace programming can use common sense when reading the code snippets below.  For anyone who needs or wants a tutorial introduction to Erlang, we can’t recommend <a href="https://learnyousomeerlang.com">Learn you some Erlang for Great Good</a> enough.</p>
</blockquote>

<h1 id="hello-world">Hello, World!</h1>

<p>Okay, we can’t have an set of example programs without including good ol’ <code class="language-plaintext highlighter-rouge">Hello world!</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%% erlang
-module(hello_world).

-export([start/0]).

start() -&gt;
    io:format("Hello world!~n").
</code></pre></div></div>

<p>Erlangers will be familiar with module declarations.  This tells the compiler what the name of the module is.</p>

<p>You also need to tell the compiler which functions to export.  This is given as list of <code class="language-plaintext highlighter-rouge">function-name/arity</code> expressions, where <code class="language-plaintext highlighter-rouge">arity</code> is the number of arguments to the function.  In this case, we export the <code class="language-plaintext highlighter-rouge">start</code> function with 0 arguments.</p>

<p>All AtomVM programs must contain a module with an exported <code class="language-plaintext highlighter-rouge">start/0</code> function.  This is the entrypoint into the program, where the AtomVM virtual machine will begin executing the program.</p>

<p>And in this case, the function just prints “Hello world!” to the console, and exits.  (The <code class="language-plaintext highlighter-rouge">~n</code> tells AtomVM to append a newline to the end of the output, but I bet you guessed that already.)</p>

<h1 id="blinky">Blinky</h1>

<p>The “Hello world!” of the IoT world is “blinky”, a program that toggles an LED on and off, every second.  It is a good program to use to test basic functionality of an application.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-module(blinky).
-export([start/0]).

-define(PIN, 2).

start() -&gt;
    gpio:set_pin_mode(?PIN, output),
    loop(?PIN, low).

loop(Pin, Level) -&gt;
    io:format("Setting pin ~p ~p~n", [Pin, Level]),
    gpio:digital_write(Pin, Level),
    timer:sleep(1000),
    loop(Pin, toggle(Level)).

toggle(high) -&gt;
    low;
toggle(low) -&gt;
    high.
</code></pre></div></div>

<p>Like the Hello World program, this program declares a module and exports the <code class="language-plaintext highlighter-rouge">start/0</code> function.</p>

<p>Many development boards come with an LED on GPIO pin 2, so let’s assume we are working with such a board, or that we have attached an LED (and accompanying resistor) to GPIO pin 2.</p>

<p>We set the pin mode of pin 2 to <code class="language-plaintext highlighter-rouge">output</code>, so that we can change the pin’s value:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gpio:set_pin_mode(?PIN, output)
</code></pre></div></div>

<p>We then enter the “loop” in the <code class="language-plaintext highlighter-rouge">loop</code> function.  We start by setting the pin to the specified level via the <code class="language-plaintext highlighter-rouge">gpio:digital_write/2</code> function, sleeping 1000 milliseconds (1 second), and then calling the <code class="language-plaintext highlighter-rouge">loop</code> function recursively, passing in the toggled value of the input level:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>loop(Pin, Level) -&gt;
    io:format("Setting pin ~p ~p~n", [Pin, Level]),
    gpio:digital_write(Pin, Level),
    timer:sleep(1000),
    loop(Pin, toggle(Level)).
</code></pre></div></div>

<p>The toggling between high and low is done via the <code class="language-plaintext highlighter-rouge">toggle</code> function, which simply flips the value from <code class="language-plaintext highlighter-rouge">high</code> to <code class="language-plaintext highlighter-rouge">low</code>, and conversely:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>toggle(high) -&gt;
    low;
toggle(low) -&gt;
    high.
</code></pre></div></div>

<p>For newcomers to Erlang, this function definition may look strange.  There are two definitions of the same function!  How can that be?  Well, in Erlang, the parameters that match the head of the function definition will be the portion of the function that will be executed.  This is exactly the way we define many functions in mathematics.</p>

<p>Newcomers to Erlang may also be concerned that this function is a recursive function that loops forever.  Won’t the program crash, because it will run out of space on the stack?</p>

<p>Again, this problem has been solved now for decades, going back to the early years of functional programming languages.  This function is known as a <em>tail recursive</em> function, meaning that the last function call in the function definition is a recursive call to itself.  In this case, the compiler knows that the function is tail recursive, and instead of pushing a new frame onto the runtime stack, the</p>

<blockquote>
  <p>Exercise for the reader: What about data that is local to the function?  Doesn’t a tail recursive function call create a memory leak?  Explain why not.  (Hint: Is any data that is not passed into the tail recursive function as a parameter of any value?)</p>
</blockquote>

<h1 id="blinky2">Blinky2</h1>

<p>The <code class="language-plaintext highlighter-rouge">blinky</code> program is nice and small, but there is a small problem with it.  The program runs in a non-terminating loop (which in itself, is fine), but the AtomVM VM is stuck in that loop, and can’t do anything else.  How do we get our programs to do more than one thing at a time?</p>

<p>For this, we need to spawn our functions in what are called Erlang processes.  Processes are not true operating system-level processes, but they share some of the same properties as OS-level processes, and in many ways AtomVM provides a very OS-like environment for your application.</p>

<p>Like an operating system schedules OS processes for execution on a CPU, the AtomVM virtual machine schedules Erlang processes independently from one another and executes them in parallel.  You can therefore spawn multiple processes, and the AtomVM virtual machine will <em>pre-emptively</em> execute the processes in “parallel”, even if it means time-slicing multiple processes on a device with a single CPU core.</p>

<p>The change to the above program is very simple.  We already have the <code class="language-plaintext highlighter-rouge">toggle/3</code> function defined.  All we need to do is spawn the function in a new process.  Syntactically, this looks like the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spawn(fun() -&gt; toggle(2, 1000, low) end)
</code></pre></div></div>

<p>There are several variants of the built-in <code class="language-plaintext highlighter-rouge">spawn</code> function, but the above example takes an anonymous function, which just calls the <code class="language-plaintext highlighter-rouge">toggle/3</code> function with the desired parameters.</p>

<p>Let’s pretend we have another LED attached to pin 4.  We can spawn another function that toggles that LED at a different time interval (say, half a second):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spawn(fun() -&gt; toggle(4, 500, low) end)
</code></pre></div></div>

<p>We now have two separate functions running in parallel, once toggling the LED on pin 2 once a second, and the other toggling the LED on pin 4 every 500ms.</p>

<p>We don’t want the program to terminate, because the processes are running in the background, so we tell the <code class="language-plaintext highlighter-rouge">start/0</code> function to just sleep forever after it has spawned the two processes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timer:sleep(infinity)
</code></pre></div></div>

<p>Here is the full program, in its entirety:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%% erlang
-module(blinky2).

-export([start/0]).

start() -&gt;
    gpio:set_pin_mode(2, output),
    gpio:set_pin_mode(4, output),
    spawn(fun() -&gt; toggle(2, 1000, low) end),
    spawn(fun() -&gt; toggle(4, 500, low) end),
    timer:sleep(infinity).

toggle(Pin, SleepMs, low) -&gt;
    gpio:digital_write(Pin, low),
    timer:sleep(SleepMs),
    toggle(Pin, SleepMs, high);
toggle(Pin, SleepMs, high) -&gt;
    gpio:digital_write(Pin, high),
    timer:sleep(SleepMs),
    toggle(Pin, SleepMs, low).
</code></pre></div></div>

<h1 id="more-to-come">More to come!</h1>


        
          <button title="Toggle Theme" class="theme-toggle">
  <svg viewBox="0 0 32 32" width="24" height="24" fill="currentcolor">
    <circle cx="16" cy="16" r="14" fill="none" stroke="currentcolor" stroke-width="4"></circle>
    <path d="
             M 16 0
             A 16 16 0 0 0 16 32
             z">
    </path>
  </svg>
</button>

        
        <div class="credits">&copy;&nbsp;2025&nbsp;atomvm.net
          &nbsp;
          •
          &nbsp;Theme&nbsp; <a href="https://github.com/abhinavs/moonwalk" target="_blank" rel="noreferrer">Moonwalk</a>
        </div>
      </div>
    </main></body>
</html>
